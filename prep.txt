Of course! Let’s go over **Java 8** features clearly, with **examples**.

Java 8 (released in March 2014) introduced **major new programming features**. Here’s a list of the most important ones:

---

## 1. **Lambda Expressions**
- Java 8 allows you to pass **code** as a method argument (functional programming).
- Syntax: `(parameters) -> { body }`

### Example:
```java
import java.util.*;

public class LambdaExample {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("apple", "banana", "cherry");
        
        // Traditional way
        for (String s : list) {
            System.out.println(s);
        }

        // Java 8 Lambda
        list.forEach(item -> System.out.println(item));
    }
}
```

---

## 2. **Functional Interfaces**
- An interface with exactly **one abstract method** is called a **Functional Interface**.
- Annotated with `@FunctionalInterface`.

### Example:
```java
@FunctionalInterface
interface MyFunctionalInterface {
    void display();
}

public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        MyFunctionalInterface msg = () -> System.out.println("Hello World");
        msg.display();
    }
}
```

---

## 3. **Streams API**
- Process collections (like Lists) **in a functional style**.
- Operations like `filter`, `map`, `reduce`, etc.

### Example:
```java
import java.util.Arrays;
import java.util.List;

public class StreamExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("John", "Jane", "Jack", "Jill");

        // Print names starting with 'J'
        names.stream()
             .filter(name -> name.startsWith("J"))
             .forEach(System.out::println);
    }
}
```

---

## 4. **Default Methods in Interfaces**
- Interfaces can now have **methods with a body** (using `default` keyword).

### Example:
```java
interface Vehicle {
    default void start() {
        System.out.println("Vehicle is starting");
    }
}

class Car implements Vehicle {}

public class DefaultMethodExample {
    public static void main(String[] args) {
        Car car = new Car();
        car.start();
    }
}
```

---

## 5. **Method References**
- Shorter way to call a method using `::` operator.

### Example:
```java
import java.util.Arrays;
import java.util.List;

public class MethodReferenceExample {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("a", "b", "c");

        // Using method reference
        list.forEach(System.out::println);
    }
}
```

---

## 6. **Optional Class**
- Avoid **NullPointerException**.
- Represents a value that might be **present** or **absent**.

### Example:
```java
import java.util.Optional;

public class OptionalExample {
    public static void main(String[] args) {
        Optional<String> optional = Optional.of("Java 8");

        System.out.println(optional.isPresent());  // true
        System.out.println(optional.get());        // Java 8
    }
}
```

---

## 7. **New Date and Time API (java.time)**
- Better replacement for old `Date` and `Calendar`.

### Example:
```java
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.LocalDateTime;

public class DateTimeExample {
    public static void main(String[] args) {
        LocalDate date = LocalDate.now();
        LocalTime time = LocalTime.now();
        LocalDateTime dateTime = LocalDateTime.now();

        System.out.println("Date: " + date);
        System.out.println("Time: " + time);
        System.out.println("DateTime: " + dateTime);
    }
}
```

---

## 8. **Collectors**
- Used with streams to **collect** data into lists, sets, maps, etc.

### Example:
```java
import java.util.List;
import java.util.stream.Collectors;
import java.util.Arrays;

public class CollectorsExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("apple", "banana", "cherry");

        List<String> upperCaseNames = names.stream()
                                           .map(String::toUpperCase)
                                           .collect(Collectors.toList());

        System.out.println(upperCaseNames);
    }
}
```

---

## Quick Summary Table:

| Feature                  | Purpose                                 | Keyword/Example |
|---------------------------|-----------------------------------------|-----------------|
| Lambda Expression         | Anonymous functions                    | `x -> x*x` |
| Functional Interface      | Interface with one abstract method     | `@FunctionalInterface` |
| Stream API                | Functional-style operations on data    | `.stream()` |
| Default Method            | Methods in interface with body         | `default void method()` |
| Method Reference          | Reference to a method                  | `System.out::println` |
| Optional                  | Avoid null checks                      | `Optional.of()` |
| New Date/Time API         | New time package (`java.time`)          | `LocalDate.now()` |
| Collectors                | Collect Stream results into containers | `Collectors.toList()` |

---------------------------------------------------------------------------------------------------------------------


JAVA 21:

Sure! Let’s go through the **Java 21** features (released in **September 2023**).  
Java 21 is a **Long-Term Support (LTS)** release, and it brings **many improvements** over Java 17/20.

Here’s a clean and clear list with explanations:

---

# 🔥 Java 21 Key Features

## 1. **Record Patterns (Standard)**
- Simplifies extracting fields from **records**.
- Matches parts of data easily.

### Example:
```java
record Point(int x, int y) {}

public class RecordPatternExample {
    public static void main(String[] args) {
        Object obj = new Point(1, 2);
        
        if (obj instanceof Point(int x, int y)) {
            System.out.println("X: " + x + ", Y: " + y);
        }
    }
}
```

✅ **No more manual casting!**

---

## 2. **Pattern Matching for Switch (Standard)**
- `switch` is now **smarter**: can match types and patterns.
  
### Example:
```java
public class SwitchPatternExample {
    public static void main(String[] args) {
        Object obj = "Hello";

        switch (obj) {
            case String s -> System.out.println("It's a string: " + s);
            case Integer i -> System.out.println("It's an integer: " + i);
            default -> System.out.println("Unknown type");
        }
    }
}
```

✅ **No need for `instanceof` + casting manually!**

---

## 3. **Virtual Threads (Standard)**
- Lightweight, super-efficient threads.
- Handles **millions** of concurrent tasks easily.

### Example:
```java
public class VirtualThreadExample {
    public static void main(String[] args) {
        Runnable task = () -> System.out.println("Running in thread: " + Thread.currentThread());

        Thread.startVirtualThread(task);
    }
}
```

✅ **Concurrency made easy**, like Golang’s goroutines!

---

## 4. **Sequenced Collections (Standard)**
- New interfaces: `SequencedCollection`, `SequencedSet`, `SequencedMap`.
- Access elements in **defined order** (first, last).

### Example:
```java
import java.util.LinkedHashSet;

public class SequencedExample {
    public static void main(String[] args) {
        LinkedHashSet<String> set = new LinkedHashSet<>();
        set.add("First");
        set.add("Second");

        System.out.println(set.getFirst()); // First
        System.out.println(set.getLast());  // Second
    }
}
```

✅ **Collections with order-awareness!**

---

## 5. **String Templates (Preview)**
- Makes string formatting **easier and safer**.

### Example:
```java
// NOTE: String Templates is preview in Java 21, full usage depends on IDE + --enable-preview flag

String name = "John";
String greeting = STR."Hello, \{name}!";
System.out.println(greeting);
```

✅ No need for clumsy `String.format()` anymore!

---

## 6. **Unnamed Variables and Patterns (Preview)**
- Use `_` for unused variables.
  
### Example:
```java
record Data(String name, int age) {}

public class UnnamedExample {
    public static void main(String[] args) {
        Data data = new Data("Alice", 30);

        if (data instanceof Data(String name, _)) { // age is ignored
            System.out.println("Name is " + name);
        }
    }
}
```

✅ Cleaner code if you don’t care about some values!

---

## 7. **Scoped Values (Incubator)**
- Safer alternative to `ThreadLocal`.
- Share immutable values between threads.

✅ Improves thread programming even more (used with Virtual Threads).

---

# 🛠 Other Improvements:
| Feature | Short Description |
|:--------|:------------------|
| Foreign Function & Memory API (Standard) | Interact with native code (like C libraries) directly |
| Deprecation of old APIs | Old things like the `SecurityManager` are being removed |
| Performance Improvements | Faster Garbage Collection, faster code execution |
| Better Pattern Matching | Simplified and more powerful pattern matching |

---

# ⚡ Java 21 Quick Summary Table

| Area | Improvement |
|------|-------------|
| Language | Pattern matching, Record patterns, Unnamed variables |
| Concurrency | Virtual Threads, Scoped Values |
| Collections | Sequenced Collections |
| Strings | String Templates |
| Native Interfacing | Foreign Function & Memory API |

---

# 🔥 Final Words:
- **Java 21 = Modern + Fast + Clean.**
- Focus is on: **Concurrency**, **Pattern Matching**, **Better Collections**, and **Simplified Syntax**.
- It is **LTS**, so it's a very good version to upgrade to for real-world applications.

---

Would you also like me to show you a **small Java 21 real-world example**, like a Web Server using **Virtual Threads**? 🚀  
(It's very cool and only 10 lines!) 

------------------------------------------------------------------------------------------------------

Exceptions:

Got it! Let’s go **deep** into **Exceptions in Java** —  
I'll explain **concepts**, **types**, **hierarchy**, **handling**, and **custom exceptions**  
**with clear examples and explanations.**  
---

# 🌟 What is an Exception in Java?

- An **Exception** is an **event** that **disrupts** the normal flow of a program.
- It occurs during **runtime** (sometimes **compile time**) and can cause the program to **terminate** abnormally.

---

# 🌟 Exception Hierarchy in Java

```
Object
 └── Throwable
      ├── Error        (serious problems, not handled by program)
      └── Exception    (can be handled by program)
           ├── RuntimeException (unchecked)
           └── Other Exceptions (checked)
```

▶ **Throwable** is the superclass of all errors and exceptions.  
▶ **Error**: Problems **outside** the program’s control (e.g., OutOfMemoryError).  
▶ **Exception**: Problems that **programs should handle**.

---

# 🌟 Types of Exceptions

| Type               | Example | Description |
|--------------------|---------|-------------|
| **Checked Exception** | IOException, SQLException | Checked at compile-time. |
| **Unchecked Exception** | NullPointerException, ArithmeticException | Occur at runtime. |
| **Error** | OutOfMemoryError, StackOverflowError | Critical system errors. |

---

# 🌟 Checked vs Unchecked Exceptions

| Checked Exception | Unchecked Exception |
|-------------------|---------------------|
| Caught or declared in method signature | No need to catch or declare |
| Compiler forces handling | Compiler does not force |
| Example: IOException | Example: ArithmeticException |

---

# 🌟 Java Exception Handling Mechanisms

- **try**: Code that may throw exception
- **catch**: Code that handles exception
- **finally**: Code that executes **always** (even if exception happens or not)
- **throw**: Used to **explicitly throw** an exception
- **throws**: Used to **declare** an exception

---

# 🌟 Basic Exception Handling Example

```java
public class ExceptionExample {
    public static void main(String[] args) {
        try {
            int result = 10 / 0;  // This will throw ArithmeticException
            System.out.println(result);
        } catch (ArithmeticException e) {
            System.out.println("Cannot divide by zero!");
        } finally {
            System.out.println("Finally block always executes");
        }
    }
}
```

▶ **Output:**
```
Cannot divide by zero!
Finally block always executes
```

---

# 🌟 `throw` keyword Example
(Manually throwing an exception)

```java
public class ThrowExample {
    public static void main(String[] args) {
        int age = 15;
        if (age < 18) {
            throw new ArithmeticException("Age must be 18 or above.");
        } else {
            System.out.println("Access granted");
        }
    }
}
```

---

# 🌟 `throws` keyword Example
(Declaring an exception)

```java
import java.io.*;

public class ThrowsExample {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter something: ");
        String input = reader.readLine();
        System.out.println("You entered: " + input);
    }
}
```
▶ **Note**: `throws IOException` means **method can throw IOException**, caller should handle it.

---

# 🌟 Multiple catch blocks

You can catch **different types** of exceptions separately:

```java
public class MultipleCatchExample {
    public static void main(String[] args) {
        try {
            int arr[] = new int[5];
            arr[5] = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println("Arithmetic Exception occurred");
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Array Index Exception occurred");
        } catch (Exception e) {
            System.out.println("Parent Exception occurred");
        }
    }
}
```

---

# 🌟 Custom Exception in Java

You can create your own exceptions by **extending Exception** class.

## Step-by-Step:

### Step 1: Create Custom Exception
```java
class InvalidAgeException extends Exception {
    InvalidAgeException(String message) {
        super(message);
    }
}
```

### Step 2: Use the Custom Exception
```java
public class CustomExceptionExample {
    static void validate(int age) throws InvalidAgeException {
        if (age < 18) {
            throw new InvalidAgeException("Age is less than 18 - Not Allowed");
        } else {
            System.out.println("Welcome to Voting!");
        }
    }


    public static void main(String[] args) {
        try {
            validate(16);
        } catch (InvalidAgeException e) {
            System.out.println("Exception caught: " + e.getMessage());
        }
    }
}
```

▶ **Output:**
```
Exception caught: Age is less than 18 - Not Allowed
```

---

# 🌟 Best Practices in Exception Handling
- Catch only those exceptions you can handle properly.
- Use **specific** exceptions, not general ones (`Exception` class).
- Never swallow exceptions (don't do just empty `catch` blocks).
- Always clean up resources (`finally` or `try-with-resources`).

---

# 🌟 try-with-resources (Auto close resources)

Introduced in **Java 7**, improved in **Java 9**.

```java
import java.io.*;

public class TryWithResourcesExample {
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader("test.txt"))) {
            System.out.println(br.readLine());
        } catch (IOException e) {
            System.out.println("Exception handled");
        }
    }
}
```
✅ The resource (`BufferedReader`) **automatically closes** after the try block.

---

# 🔥 Final Quick Summary:

| Keyword | Purpose |
|---------|---------|
| `try` | Code to monitor |
| `catch` | Code to handle exception |
| `finally` | Always execute (cleanup) |
| `throw` | Throw an exception manually |
| `throws` | Declare that method may throw exception |
| Custom Exception | User-defined error classes |

---

Would you like me to also show a **real-world mini project** (e.g., Banking System) using **Custom Exceptions + Exception Handling** together? 🚀  
It would make the whole topic even more practical! 

----------------------------------------------------------------------------------------------------------------------------

Colllections:


Absolutely! Let’s dive deep into the **Java Collections API**:  
I’ll explain **concepts**, **interfaces**, **important classes**, **examples** and **clear explanations**.

---

# 🌟 What is the Collections API?

- **Collections API** is a **framework** that provides **ready-to-use classes and interfaces** to store, retrieve, and manipulate groups of objects easily.
- It handles **data structures** like **List, Set, Map, Queue, Deque** etc.

✅ It’s part of **java.util** package.

---

# 🌟 Collections Framework Architecture

```
Collection (Interface)
 ├── List (Interface)
 │    ├── ArrayList
 │    ├── LinkedList
 │    └── Vector
 │         └── Stack
 ├── Set (Interface)
 │    ├── HashSet
 │    ├── LinkedHashSet
 │    └── TreeSet
 └── Queue (Interface)
      ├── PriorityQueue
      └── ArrayDeque

Map (Interface)
 ├── HashMap
 ├── LinkedHashMap
 ├── TreeMap
 └── Hashtable
     └── Properties
```

---

# 🌟 Important Interfaces

| Interface | Description |
|-----------|-------------|
| Collection | Root of the Collection hierarchy |
| List | Ordered collection (allows duplicates) |
| Set | Unordered, unique elements |
| Queue | FIFO structure (first-in, first-out) |
| Deque | Double-ended queue |
| Map | Key-value pairs, not part of Collection hierarchy |

---

# 🌟 Now let's see each one in detail:

---

## 1. List Interface
- **Ordered** collection.
- **Allows duplicates**.
- Access by **index** (0-based).

### Important Implementations:
| Class | Feature |
|-------|---------|
| ArrayList | Dynamic array, fast access |
| LinkedList | Doubly linked list, fast insertion/deletion |
| Vector | Thread-safe version of ArrayList |
| Stack | LIFO (Last In, First Out) structure |

### Example:
```java
import java.util.*;

public class ListExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Apple");  // Duplicate allowed

        System.out.println(list); // [Apple, Banana, Apple]
    }
}
```

---

## 2. Set Interface
- **Unordered** collection.
- **No duplicates allowed**.

### Important Implementations:
| Class | Feature |
|-------|---------|
| HashSet | No order, fast access |
| LinkedHashSet | Maintains insertion order |
| TreeSet | Sorted (ascending order) |

### Example:
```java
import java.util.*;

public class SetExample {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        set.add("Dog");
        set.add("Cat");
        set.add("Dog"); // Duplicate ignored

        System.out.println(set); // [Dog, Cat] or [Cat, Dog] (order not guaranteed)
    }
}
```

---

## 3. Queue Interface
- **FIFO** (First-In-First-Out) structure.
- Useful for task scheduling, printing jobs.

### Important Implementations:
| Class | Feature |
|-------|---------|
| PriorityQueue | Elements ordered by priority |
| ArrayDeque | Resizable array, double-ended queue |

### Example:
```java
import java.util.*;

public class QueueExample {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        queue.add("First");
        queue.add("Second");
        queue.add("Third");

        System.out.println(queue.poll()); // First
        System.out.println(queue.poll()); // Second
    }
}
```

---

## 4. Deque Interface
- **Double-ended queue** (insert/remove from both ends).

### Important Implementation:
| Class | Feature |
|-------|---------|
| ArrayDeque | Efficient insertions/removals |

### Example:
```java
import java.util.*;

public class DequeExample {
    public static void main(String[] args) {
        Deque<String> deque = new ArrayDeque<>();
        deque.addFirst("Head");
        deque.addLast("Tail");

        System.out.println(deque); // [Head, Tail]
    }
}
```

---

## 5. Map Interface
- **Key-Value pairs**.
- **Keys are unique**, values can be duplicate.
- Not a subtype of Collection.

### Important Implementations:
| Class | Feature |
|-------|---------|
| HashMap | Fast, unordered |
| LinkedHashMap | Maintains insertion order |
| TreeMap | Sorted by keys |
| Hashtable | Thread-safe version of HashMap |
| Properties | Specialized Hashtable for configs |

### Example:
```java
import java.util.*;

public class MapExample {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "One");
        map.put(2, "Two");
        map.put(1, "Uno"); // Overwrites previous value

        System.out.println(map); // {1=Uno, 2=Two}
    }
}
```

---

# 🌟 Utility Class - `Collections`

- Part of **java.util.Collections**.
- Provides **static methods** to operate on collections like **sort**, **shuffle**, **reverse**, **min**, **max**, **synchronized collection** etc.

### Example:
```java
import java.util.*;

public class CollectionsExample {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("Banana", "Apple", "Cherry");
        Collections.sort(list);
        System.out.println(list); // [Apple, Banana, Cherry]
    }
}
```

---

# 🌟 Key Differences Table

| Collection Type | Allows Duplicates | Maintains Order | Thread-safe? |
|-----------------|-------------------|-----------------|--------------|
| List | Yes | Yes | No (except Vector) |
| Set | No | No (HashSet) / Yes (LinkedHashSet) / Sorted (TreeSet) | No |
| Queue | Maybe | Yes (LinkedList), Priority-based (PriorityQueue) | No |
| Map | Keys unique, values can repeat | No (HashMap) / Yes (LinkedHashMap) / Sorted (TreeMap) | No (except Hashtable) |

---

# 🌟 Important Points

- **ArrayList** is preferred for **random access**.
- **LinkedList** is preferred for **frequent insertion/deletion**.
- **HashSet** does not maintain order, **LinkedHashSet** does.
- **HashMap** is faster but **unsynchronized**; **Hashtable** is slower but **synchronized**.
- Use **TreeMap** or **TreeSet** for **sorted** collections.
- Always prefer **StringBuilder** for string operations in loops inside collections.

---

# 🚀 Bonus: Java 8 Stream API (working with Collections)

```java
import java.util.*;

public class StreamExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Ram", "Shyam", "John", "Rahul");

        names.stream()
             .filter(name -> name.startsWith("R"))
             .forEach(System.out::println);
    }
}
```

▶ Output:
```
Ram
Rahul
```
✅ Streams provide **functional-style operations** on Collections.

---

# 🔥 Conclusion

The **Java Collections Framework** is **powerful**, **flexible**, and **essential** for building efficient applications.  
It **standardizes** how data structures are handled and **saves huge development time**.

---
Would you also like me to create a **real-world example** project (like a **Library Management System**) using List, Set, and Map together? 🚀  
It will make it super easy to understand how Collections work together!

--------------------------------------------------------------------------------------------------


Good question!  
Many Java beginners confuse **Collection** and **Collections** — but they are **very different**.

Let me explain **clearly and simply**:

---

# 🌟 Collection vs Collections in Java

| Feature | Collection | Collections |
|---------|------------|-------------|
| **Type** | Interface | Utility Class (final class) |
| **Package** | `java.util` | `java.util` |
| **Purpose** | Root interface for all collection types (List, Set, Queue) | Utility class for operating on collections (methods like `sort()`, `reverse()`, etc.) |
| **Extends/Implements** | Interface extended by List, Set, Queue | Class that contains only static methods |
| **Example** | `Collection<String> list = new ArrayList<>();` | `Collections.sort(list);` |

---

# 🌟 1. What is **Collection**?

- **Collection** is an **interface**.
- It is the **root** of the **Collection Framework**.
- Other interfaces like **List**, **Set**, **Queue** **extend** `Collection`.

👉 **Collection defines** basic methods like:
```java
add(), remove(), size(), clear(), iterator()
```

✅ Example:
```java
import java.util.*;

public class CollectionExample {
    public static void main(String[] args) {
        Collection<String> collection = new ArrayList<>();
        collection.add("Apple");
        collection.add("Banana");

        System.out.println(collection); // [Apple, Banana]
    }
}
```

---

# 🌟 2. What is **Collections**?

- **Collections** is a **final class** (cannot be inherited).
- It is a **utility/helper class**.
- It contains **only static methods** to operate on Collection objects.
  
👉 **Collections provides** methods like:
```java
sort(), reverse(), shuffle(), min(), max(), synchronizedList()
```

✅ Example:
```java
import java.util.*;

public class CollectionsExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Banana");
        list.add("Apple");
        list.add("Mango");

        Collections.sort(list); // Sorting list
        System.out.println(list); // [Apple, Banana, Mango]
    }
}
```

---

# 🌟 Visual Summary:

```
java.util.Collection    --> Interface  (Root for List, Set, Queue)
java.util.Collections   --> Class      (Utility methods for Collection)
```

---

# 🌟 Quick Trick to Remember
- **Collection** → *interface* → *what* a collection *is*.
- **Collections** → *class* → *what you can *do* with collections (like sort, search).

---

# 🌟 Bonus Tip
⚡ Don't forget —  
- **Collection** is the **building block**.  
- **Collections** is the **toolbox** for operating on collections.

---
----------------------------------------------------------------------------------------------------------------------------------


Awesome! You are asking exactly the right set of topics for deep Java mastery 🔥.  
Let’s go one by one, **detailed + examples + easy comparison tables**.

---

# 🌟 1. ArrayList vs LinkedList vs Vector vs Stack

| Feature       | ArrayList | LinkedList | Vector | Stack |
|---------------|-----------|------------|--------|-------|
| Type          | Growable array | Doubly-linked list | Growable array (thread-safe) | Extension of Vector (LIFO) |
| Performance   | Fast random access (get/set) | Fast insert/delete | Slower than ArrayList (due to synchronization) | Stack operations (push/pop) |
| Thread-safe   | ❌ No | ❌ No | ✅ Yes | ✅ Yes |
| Use case      | Frequent access | Frequent add/remove | Multi-threaded access | LIFO (Last-In-First-Out) |
| Synchronization | No | No | Yes | Yes |

---

## ✅ Simple Examples:

### ArrayList:
```java
import java.util.*;

public class ArrayListExample {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        System.out.println(list); // [A, B]
    }
}
```

### LinkedList:
```java
import java.util.*;

public class LinkedListExample {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        list.add("X");
        list.addFirst("Y");
        System.out.println(list); // [Y, X]
    }
}
```

### Vector:
```java
import java.util.*;

public class VectorExample {
    public static void main(String[] args) {
        Vector<Integer> v = new Vector<>();
        v.add(1);
        v.add(2);
        System.out.println(v); // [1, 2]
    }
}
```

### Stack:
```java
import java.util.*;

public class StackExample {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();
        stack.push(10);
        stack.push(20);
        System.out.println(stack.pop()); // 20
    }
}
```

---

# 🌟 2. Iterator vs ListIterator

| Feature        | Iterator | ListIterator |
|----------------|----------|--------------|
| Applicable for | Collection | List only (ArrayList, LinkedList) |
| Direction      | Forward only | Forward and Backward |
| Modify list?   | Can remove elements | Can add, remove, replace elements |
| Methods        | `hasNext()`, `next()`, `remove()` | `hasNext()`, `next()`, `hasPrevious()`, `previous()`, `add()`, `remove()`, `set()` |

---

## ✅ Example:

### Iterator Example (forward only):
```java
import java.util.*;

public class IteratorExample {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("A", "B", "C");
        Iterator<String> it = list.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
    }
}
```

### ListIterator Example (forward + backward):
```java
import java.util.*;

public class ListIteratorExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("X", "Y", "Z"));
        ListIterator<String> lit = list.listIterator();

        while (lit.hasNext()) {
            System.out.println(lit.next()); // forward
        }

        while (lit.hasPrevious()) {
            System.out.println(lit.previous()); // backward
        }
    }
}
```

---

# 🌟 3. Comparable vs Comparator

| Feature           | Comparable | Comparator |
|-------------------|------------|------------|
| Package           | `java.lang` | `java.util` |
| Sorting logic     | Inside the class itself | Outside the class (separate class) |
| Method to override| `compareTo(Object o)` | `compare(Object o1, Object o2)` |
| Single/Multiple sort conditions | Single | Multiple possible |
| Example usage     | Natural sorting (name, id) | Custom sorting (salary, age) |

---

## ✅ Examples:

### Comparable (natural order sorting)
```java
class Student implements Comparable<Student> {
    int rollno;
    String name;
    Student(int rollno, String name) {
        this.rollno = rollno;
        this.name = name;
    }
    public int compareTo(Student s) {
        return this.rollno - s.rollno;
    }
}

import java.util.*;

public class ComparableExample {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student(3, "John"));
        list.add(new Student(1, "Jane"));
        
        Collections.sort(list);
        for (Student s : list)
            System.out.println(s.rollno + " " + s.name);
    }
}
```

### Comparator (custom order sorting)
```java
import java.util.*;

class Student {
    int rollno;
    String name;
    Student(int rollno, String name) {
        this.rollno = rollno;
        this.name = name;
    }
}

class NameComparator implements Comparator<Student> {
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name);
    }
}

public class ComparatorExample {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student(3, "John"));
        list.add(new Student(1, "Jane"));
        
        Collections.sort(list, new NameComparator());
        for (Student s : list)
            System.out.println(s.rollno + " " + s.name);
    }
}
```

---

# 🌟 4. Map Hierarchy

✅ In Java, **Map** is **not** part of Collection interface, but it’s very important.

```
Map (Interface)
 ├── HashMap
 ├── LinkedHashMap
 ├── TreeMap
 ├── Hashtable
     └── Properties
```

| Map Type | Characteristics |
|----------|-----------------|
| HashMap | Unordered, allows null key and values |
| LinkedHashMap | Maintains insertion order |
| TreeMap | Sorted order (by keys) |
| Hashtable | Thread-safe, no nulls |
| Properties | Specialized for configuration properties (String keys & values) |

---

## ✅ Example:

### HashMap:
```java
import java.util.*;

public class HashMapExample {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(101, "A");
        map.put(102, "B");

        System.out.println(map); // {101=A, 102=B}
    }
}
```

### TreeMap:
```java
import java.util.*;

public class TreeMapExample {
    public static void main(String[] args) {
        TreeMap<Integer, String> map = new TreeMap<>();
        map.put(200, "X");
        map.put(100, "Y");

        System.out.println(map); // {100=Y, 200=X} (sorted)
    }
}
```

---

# 🚀 Quick Summary Diagrams:

### 🔥 Collections vs Map
```
java.util.Collection (Interface)
  ├── List
  ├── Set
  ├── Queue

java.util.Map (Interface)
  ├── HashMap
  ├── TreeMap
  ├── LinkedHashMap
  ├── Hashtable
```

---
# 🔥 Conclusion:

- **ArrayList** = Best for random access
- **LinkedList** = Best for frequent insert/delete
- **Vector/Stack** = Thread-safe collections
- **Iterator** = One-way
- **ListIterator** = Two-way
- **Comparable** = Natural order inside class
- **Comparator** = Custom order outside class
- **Map** = Key-Value storage with various flavors (unordered, ordered, sorted, thread-safe)

---

Would you also like me to prepare a quick **mind-map diagram** 🎯 for all these (Collections, Iterators, Comparators, Maps)?  
It'll make your notes super easy and organized! 🚀
---------------------------------------------------------------------------------------------------------------------


Excellent!  
You are picking all **core Java** topics — important for interviews, real-world coding, and advanced learning (like Spring, concurrency, etc.).  
Let’s go **deep** but **clear** step-by-step.

---

# 🌟 Java Multithreading: Full Explanation

---

# 1️⃣ What is Multithreading?

- **Multithreading** means running **multiple threads** *simultaneously*.
- Each **thread** is like a **separate path of execution** (mini-program).
- It improves **CPU utilization**, **application responsiveness**, and **performance**.

✅ **Thread** = lightweight process.

---

# 2️⃣ Thread Creation Methods

Java provides **two ways** to create a thread:

| Method | How? | Example |
|--------|-----|---------|
| 1. Extend `Thread` class | Inherit and override `run()` method | `class MyThread extends Thread` |
| 2. Implement `Runnable` interface | Implement `run()` and pass it to `Thread` object | `class MyRunnable implements Runnable` |

---

## ✅ Example 1: Extending Thread class
```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running...");
    }
}

public class TestThread {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();  // start() internally calls run()
    }
}
```

---

## ✅ Example 2: Implementing Runnable interface
```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable thread is running...");
    }
}

public class TestRunnable {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        t1.start();
    }
}
```

---

# 3️⃣ Thread Lifecycle (States)

A thread goes through **5 major states**:

```
New --> Runnable --> Running --> Blocked/Waiting --> Terminated
```

| State | Description |
|-------|-------------|
| New | Thread object created but not started |
| Runnable | After `start()`, ready to run |
| Running | Actively executing code |
| Blocked/Waiting | Temporarily paused (waiting for resource/another thread) |
| Terminated | Execution completed |

---

✅ Example showing states:
```java
Thread t = new Thread();
System.out.println(t.getState());  // NEW
t.start();
System.out.println(t.getState());  // RUNNABLE
```

---

# 4️⃣ Inter-Thread Communication

- Threads **sometimes need to communicate** with each other.
- Java provides **`wait()`**, **`notify()`**, and **`notifyAll()`** methods to coordinate threads.
- These methods must be called **inside synchronized blocks**.

| Method | Meaning |
|--------|---------|
| wait() | Pause and release lock until notified |
| notify() | Wake up one waiting thread |
| notifyAll() | Wake up all waiting threads |

---

## ✅ Example:

```java
class SharedResource {
    synchronized void printTable(int n) {
        for (int i = 1; i <= 5; i++) {
            System.out.println(n * i);
            try { wait(1000); } catch (Exception e) { System.out.println(e); }
        }
    }
}

public class TestCommunication {
    public static void main(String[] args) {
        SharedResource obj = new SharedResource();

        Thread t1 = new Thread(() -> obj.printTable(5));
        Thread t2 = new Thread(() -> obj.printTable(100));

        t1.start();
        t2.start();
    }
}
```

---

# 5️⃣ Synchronization

- **When multiple threads access the same resource**, **data inconsistency** can happen.
- **Synchronization** ensures **only one thread accesses** the resource at a time.

✅ Java provides **synchronized keyword** to control this.

---

## ✅ Synchronization Example:

```java
class Table {
    synchronized void printTable(int n) {  // synchronized method
        for (int i = 1; i <= 5; i++) {
            System.out.println(n * i);
            try { Thread.sleep(400); } catch (Exception e) { }
        }
    }
}

public class TestSync {
    public static void main(String[] args) {
        Table obj = new Table(); // only one object

        Thread t1 = new Thread(() -> obj.printTable(5));
        Thread t2 = new Thread(() -> obj.printTable(100));

        t1.start();
        t2.start();
    }
}
```

✅ You can synchronize **method** or **block**:
```java
synchronized(obj) {
   // critical section
}
```

---

# 🌟 Bonus Concepts in Multithreading:

| Concept | Description |
|---------|-------------|
| sleep(time) | Pause the thread temporarily |
| join() | One thread waits for another to complete |
| yield() | Pause to allow other threads a chance |
| daemon thread | Background threads (e.g., Garbage Collector) |
| thread priority | Set by `setPriority()`, ranges 1(MIN) to 10(MAX) |

---

# 🚀 Quick Diagram for Thread Lifecycle:

```
New 
  ↓ start()
Runnable
  ↓ scheduler picks
Running
  ↓
Blocked / Waiting (due to lock/sleep/join)
  ↓
Terminated (end of run() or exception)
```

---

# 🔥 Summary:

| Concept | Key Point |
|---------|-----------|
| Multithreading | Run multiple tasks at the same time |
| Thread creation | Extend Thread OR Implement Runnable |
| Thread lifecycle | New → Runnable → Running → Waiting → Terminated |
| Inter-thread communication | wait(), notify(), notifyAll() |
| Synchronization | Prevent race conditions |

---

Would you also like me to show a **real-world mini project** (like **ATM Simulation** or **Banking System**) using **multithreading, synchronization, and inter-thread communication**? 🚀

It will make everything crystal clear!  
(Just say: "Yes, show project!") ✅


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Alright! Let’s go into **PL/SQL (Procedural Language/Structured Query Language)** —  
I’ll explain **clearly** with **examples** and also **explain each example** in simple language.

This will be like a full **PL/SQL notes + tutorial** for you 🚀.

---

# 🌟 1. What is PL/SQL?

- **PL/SQL** = SQL + Programming features.
- It adds programming constructs (like **variables**, **loops**, **conditions**) to SQL.
- Used in **Oracle Databases**.
- Helps **group multiple SQL statements** inside **blocks**.

✅ **PL/SQL Block Structure:**
```sql
DECLARE
   -- Variable declarations
BEGIN
   -- SQL statements
EXCEPTION
   -- Error handling
END;
```

---

# 🌟 2. Basic PL/SQL Block Example

```sql
DECLARE
   v_name VARCHAR2(50) := 'John';
BEGIN
   DBMS_OUTPUT.PUT_LINE('Hello, ' || v_name);
END;
```

✅ **Explanation:**
- `DECLARE` section: Defines variable `v_name`.
- `BEGIN` section: Prints message using `DBMS_OUTPUT.PUT_LINE`.
- `END;` ends the block.

---

# 🌟 3. Variables and Constants

✅ **Example:**
```sql
DECLARE
   v_age NUMBER := 25;
   c_pi CONSTANT NUMBER := 3.14159;
BEGIN
   DBMS_OUTPUT.PUT_LINE('Age: ' || v_age);
   DBMS_OUTPUT.PUT_LINE('Pi Value: ' || c_pi);
END;
```

✅ **Explanation:**
- `v_age`: A normal variable.
- `c_pi`: A constant (cannot be changed).

---

# 🌟 4. Conditional Statements (IF-THEN-ELSE)

✅ **Example:**
```sql
DECLARE
   v_marks NUMBER := 80;
BEGIN
   IF v_marks >= 90 THEN
      DBMS_OUTPUT.PUT_LINE('Grade A');
   ELSIF v_marks >= 75 THEN
      DBMS_OUTPUT.PUT_LINE('Grade B');
   ELSE
      DBMS_OUTPUT.PUT_LINE('Grade C');
   END IF;
END;
```

✅ **Explanation:**
- Checks `v_marks` value and prints the corresponding grade.

---

# 🌟 5. Loops

### ➡️ Simple LOOP
```sql
DECLARE
   v_counter NUMBER := 1;
BEGIN
   LOOP
      DBMS_OUTPUT.PUT_LINE('Counter: ' || v_counter);
      v_counter := v_counter + 1;
      EXIT WHEN v_counter > 5;
   END LOOP;
END;
```

✅ **Explanation:**
- Keeps printing counter until it becomes >5.

---

### ➡️ WHILE LOOP
```sql
DECLARE
   v_counter NUMBER := 1;
BEGIN
   WHILE v_counter <= 5 LOOP
      DBMS_OUTPUT.PUT_LINE('Counter: ' || v_counter);
      v_counter := v_counter + 1;
   END LOOP;
END;
```

---

### ➡️ FOR LOOP
```sql
BEGIN
   FOR i IN 1..5 LOOP
      DBMS_OUTPUT.PUT_LINE('Value of i: ' || i);
   END LOOP;
END;
```

✅ **Explanation:**
- `i` automatically increments from 1 to 5.

---

# 🌟 6. Cursors (Handling multiple rows)

✅ **Cursor**: Used to fetch **multiple rows** one by one.

### ➡️ Implicit Cursor Example
```sql
BEGIN
   UPDATE employees SET salary = salary + 1000 WHERE department_id = 10;
   DBMS_OUTPUT.PUT_LINE(SQL%ROWCOUNT || ' rows updated.');
END;
```
- `SQL%ROWCOUNT`: Tells how many rows were affected.

---

### ➡️ Explicit Cursor Example
```sql

DECLARE
   CURSOR emp_cursor IS SELECT employee_name FROM employees;
   v_name employees.employee_name%TYPE;
BEGIN
   OPEN emp_cursor;
   LOOP
      FETCH emp_cursor INTO v_name;
      EXIT WHEN emp_cursor%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE('Employee: ' || v_name);
   END LOOP;
   CLOSE emp_cursor;
END;
```

✅ **Explanation:**
- Cursor opens → Fetches each employee name → Prints it → Closes.

---

# 🌟 7. Exception Handling

- Exceptions handle **errors** gracefully.

✅ **Example:**
```sql
DECLARE
   v_num NUMBER := 10;
   v_denom NUMBER := 0;
   v_result NUMBER;
BEGIN
   v_result := v_num / v_denom;
EXCEPTION
   WHEN ZERO_DIVIDE THEN
      DBMS_OUTPUT.PUT_LINE('Division by zero error!');
END;
```

✅ **Explanation:**
- Error occurs because division by zero is not allowed.
- `ZERO_DIVIDE` exception catches it.

---

# 🌟 8. Procedures (Reusable Blocks)

✅ **Example:**
```sql

CREATE OR REPLACE PROCEDURE greet(p_name IN VARCHAR2) IS
BEGIN
   DBMS_OUTPUT.PUT_LINE('Hello, ' || p_name || '!');
END;
```
To call the procedure:
```sql
BEGIN
   greet('jhbg');
END;
```

✅ **Explanation:**
- `greet` is a stored procedure that prints a greeting.

---

# 🌟 9. Functions (Return a value)

✅ **Example:**
```sql
CREATE OR REPLACE FUNCTION square_num(p_num IN NUMBER)
RETURN NUMBER
IS
BEGIN
   
   RETURN p_num * p_num;
END;
```
To call:
```sql

BEGIN
   v_result := square_num(4);
   DBMS_OUTPUT.PUT_LINE('Square is: ' || square_num(4));
END;
```

✅ **Explanation:**
- `square_num` returns the square of the input number.

---

# 🌟 10. Triggers (Automatic action when event occurs)

✅ **Example:**
```sql
CREATE OR REPLACE TRIGGER before_employee_insert
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
   DBMS_OUTPUT.PUT_LINE('Before inserting employee record...');
END;
```

✅ **Explanation:**
- This trigger runs automatically **before inserting** any new employee.

---

# 🚀 Bonus: Important PL/SQL Features

| Feature | Description |
|---------|-------------|
| Cursor | Process multiple rows |
| Exception | Handle runtime errors |
| Procedure | Stored block that performs action |
| Function | Stored block that returns a value |
| Trigger | Automatic execution on DML event |
| Package | Group procedures, functions together |
| Bulk Collect | Fetch multiple rows at once |
| FORALL | Fast data manipulation |

---

# 🔥 Summary Cheat Sheet

```
PL/SQL Block = DECLARE → BEGIN → EXCEPTION → END;
Variables = store data
IF/LOOP = control flow
Cursors = fetch multiple rows
Exception Handling = catch errors
Procedures/Functions = reusable programs
Triggers = automatic actions
```

---

# 📚 Would you also like?

✅ Real-world **small projects** using PL/SQL (like Banking DB, Student DB management)?  
✅ Advanced topics like **Bulk Collect**, **Dynamic SQL**, **Packages**, **Collections**?  
✅ Full **interview questions + answers** based on PL/SQL?

Just tell me! 🚀  
(Example: "Yes, show me a PL/SQL project") ✅


Awesome! Let’s dive into these **advanced PL/SQL topics**:  
**Bulk Collect**, **Dynamic SQL**, **Packages**, and **Collections** with **examples** and **detailed explanations**. This will elevate your PL/SQL skills!

---

# 🌟 1. **Bulk Collect**

The **`BULK COLLECT`** statement allows you to **fetch multiple rows at once**, reducing context switching between the PL/SQL engine and the SQL engine.

### When to Use:
- Useful when you need to fetch a large number of rows efficiently.
- Avoids looping over each row individually.

---

### ✅ Example of Bulk Collect:
```sql
DECLARE
   TYPE emp_array IS TABLE OF employees.employee_id%TYPE;
   v_emp_ids emp_array;
BEGIN
   -- Bulk collect data into PL/SQL collection
   SELECT employee_id
   BULK COLLECT INTO v_emp_ids
   FROM employees
   WHERE department_id = 10;

   -- Loop over the collection and display results
   FOR i IN 1..v_emp_ids.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_emp_ids(i));
   END LOOP;
END;
```

### **Explanation:**
- **`BULK COLLECT`**: Fetches all employee IDs where the department ID is `10` and stores them in `v_emp_ids` (PL/SQL collection).
- **`v_emp_ids.COUNT`**: Counts the number of elements in the collection.
- **Efficiency**: This reduces the number of context switches between PL/SQL and SQL engines.

---

# 🌟 2. **Dynamic SQL**

**Dynamic SQL** allows you to **build and execute SQL statements** dynamically at runtime. This is particularly useful when table/column names or conditions are not known until runtime.

### When to Use:
- When you need to execute dynamic queries based on changing conditions or user input.

---

### ✅ Example of Dynamic SQL:
```sql
DECLARE
   v_table_name VARCHAR2(50) := 'employees';
   v_sql_query VARCHAR2(1000);
BEGIN
   -- Construct the dynamic SQL query
   v_sql_query := 'SELECT COUNT(*) FROM ' || v_table_name;

   -- Execute the dynamic SQL
   EXECUTE IMMEDIATE v_sql_query;
END;
```

### **Explanation:**
- **`v_table_name`**: A variable holding the table name.
- **`EXECUTE IMMEDIATE`**: Executes the SQL string stored in `v_sql_query` dynamically.

---

### ✅ Example of Dynamic SQL with Bind Variables:
```sql
DECLARE
   v_table_name VARCHAR2(50) := 'employees';
   v_dept_id NUMBER := 10;
   v_sql_query VARCHAR2(1000);
   v_count NUMBER;
BEGIN
   -- Construct dynamic SQL with bind variables
   v_sql_query := 'SELECT COUNT(*) FROM ' || v_table_name || ' WHERE department_id = :dept_id';

   -- Execute the dynamic SQL with bind variable
   EXECUTE IMMEDIATE v_sql_query INTO v_count USING v_dept_id;

   DBMS_OUTPUT.PUT_LINE('Number of employees in department ' || v_dept_id || ': ' || v_count);
END;
```

### **Explanation:**
- **Bind Variable (`:dept_id`)**: We use `USING` to pass the value of `v_dept_id` into the dynamic SQL.
- **`EXECUTE IMMEDIATE INTO`**: Executes the dynamic SQL and stores the result into `v_count`.

---

# 🌟 3. **Packages**

A **PL/SQL package** is a **collection of related procedures**, **functions**, **variables**, and **cursors** grouped together into a single unit. This enhances modularity, reusability, and maintainability.

### Package Structure:
1. **Package Specification**: Declares the procedures, functions, and variables.
2. **Package Body**: Defines the actual logic for the procedures and functions.

---

### ✅ Example of a Simple Package:

**Package Specification (`my_package.spec`)**:
```sql
CREATE OR REPLACE PACKAGE my_package IS
   PROCEDURE greet_user(p_name IN VARCHAR2);
   FUNCTION get_employee_count RETURN NUMBER;
END my_package;
```

**Package Body (`my_package.body`)**:
```sql
CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE greet_user(p_name IN VARCHAR2) IS
   BEGIN
      DBMS_OUTPUT.PUT_LINE('Hello, ' || p_name);
   END greet_user;

   FUNCTION get_employee_count RETURN NUMBER IS
      v_count NUMBER;
   BEGIN
      SELECT COUNT(*) INTO v_count FROM employees;
      RETURN v_count;
   END get_employee_count;
END my_package;
```

### **Explanation:**
- **Package Specification**: Contains declarations of the procedures and functions.
- **Package Body**: Implements the logic of the procedures and functions.
- **`greet_user`**: A procedure that greets a user by name.
- **`get_employee_count`**: A function that returns the total number of employees.

---

### ✅ Using the Package:
```sql
BEGIN
   my_package.greet_user('Alice');  -- Calls the procedure
   DBMS_OUTPUT.PUT_LINE('Employee count: ' || my_package.get_employee_count);  -- Calls the function
END;
```

### **Explanation:**
- We call the **`greet_user`** procedure and **`get_employee_count`** function from the package.

---

# 🌟 4. **Collections in PL/SQL**

PL/SQL supports **three types of collections**:
1. **Associative Arrays**: (formerly known as PL/SQL tables)
2. **Nested Tables**
3. **Varrays** (Variable-size arrays)

---

### ➡️ **Associative Arrays** (Index-by tables)

An **associative array** is a collection of elements indexed by **unique keys** (can be integers or strings).

```sql
DECLARE
   TYPE emp_array IS TABLE OF employees.employee_id%TYPE INDEX BY VARCHAR2(10);
   v_emp_ids emp_array;
BEGIN
   v_emp_ids('A') := 101;
   v_emp_ids('B') := 102;

   DBMS_OUTPUT.PUT_LINE('Employee A ID: ' || v_emp_ids('A'));
   DBMS_OUTPUT.PUT_LINE('Employee B ID: ' || v_emp_ids('B'));
END;
```

### **Explanation:**
- **Index-by table**: Associative arrays allow you to associate an index (e.g., `'A'`, `'B'`) with a value (`employee_id`).
- **`v_emp_ids('A')`** accesses the value using the key `'A'`.

---

### ➡️ **Nested Tables**

A **nested table** is like an **array** but can be stored as a column in a database table.

```sql
DECLARE
   TYPE emp_table IS TABLE OF employees.employee_id%TYPE;
   v_emp_ids emp_table := emp_table(101, 102, 103);
BEGIN
   FOR i IN 1..v_emp_ids.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_emp_ids(i));
   END LOOP;
END;
```

### **Explanation:**
- **`emp_table`**: Defines a nested table that holds a list of `employee_id`s.
- **Looping over nested table**: We loop through all elements and print each `employee_id`.

---

### ➡️ **Varrays**

A **Varray** is a collection with a **fixed size** (i.e., the maximum number of elements is defined when you declare it).

```sql
DECLARE
   TYPE emp_varray IS VARRAY(5) OF employees.employee_id%TYPE;
   v_emp_ids emp_varray := emp_varray(101, 102, 103, 104, 105);
BEGIN
   FOR i IN 1..v_emp_ids.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_emp_ids(i));
   END LOOP;
END;
```

### **Explanation:**
- **`emp_varray`**: A Varray collection of size 5.
- **Fixed Size**: You cannot exceed the declared size of the Varray.

---

# 🚀 **Summary of Advanced PL/SQL Concepts:**

| Concept         | Description |
|-----------------|-------------|
| **Bulk Collect** | Efficiently fetch multiple rows at once |
| **Dynamic SQL**  | Build and execute SQL dynamically at runtime |
| **Packages**     | Group related procedures, functions, variables together |
| **Collections**  | Manage lists of data (Associative Arrays, Nested Tables, Varrays) |

---

Would you like to dive deeper into any of these topics, or perhaps see a **real-world project** using these advanced PL/SQL features (e.g., a **Student Database System** with Bulk Collect, Dynamic SQL, and Packages)? 😎

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


CURSOR:

declare
 cursor emp is
   select customer_number from customer_master;
   v_customer_number customer_master.customer_number%type;
begin
open emp;
 loop
   fetch emp into v_customer_number;
   exit when emp%notfound;
   dbms_output.put_line('CustNumber:'||v_customer_number);
  end loop;
  close emp;
end;
  
TRIGER:

CREATE OR REPLACE TRIGGER emp1 
BEFORE INSERT ON branch_master
FOR EACH ROW
BEGIN 
  DBMS_OUTPUT.PUT_LINE('Triggered');
END;

INSERT INTO branch_master 
VALUES ('B00704', 'JASOLAo', 'DELHI');



Procedure:

--create or replace procedure greet(name in varchar)
--as
--begin 
--dbms_output.put_line('Hi '||name);
--end;

begin
greet('Balaji');
end


FUNCTION:

--create or replace function add1
--(num1 in number,num2 in number)
--return number
--is 
--begin
 -- return num1+num2;
 --end ;
declare result number;
 begin
result:= add1(1,2);
dbms_output.put_line(result);
 end;
-----------------------------------------------------------------------------


package com.cts;

// Renamed the main class to avoid conflict with the built-in Exception class
public class CustomExceptionExample {
    public static void main(String[] args) {
        try {
            CustomExample.validate(16);
        } catch (InvalidAgeException e) {
            System.out.println("Exception caught: " + e.getMessage());
        }
    }
}

class CustomExample {
    static void validate(int age) throws InvalidAgeException {
        if (age < 18) {
            throw new InvalidAgeException("Invalid");
        } else {
            System.out.println("Valid");
        }
    }
}

class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message);
    }
}
---------------------------------------------------------------------------------------


